
@rendermode InteractiveWebAssembly
@inject IJSRuntime js


<style>

.link {
  stroke: #000;
  stroke-width: 1.0px;
}

.node {
  cursor: move;
  fill: #ccc;
  stroke: #000;
  stroke-width: 1.0px;
}

.node.fixed {
  stroke: #00f;
}

.text {
  stroke-width: 0.5px;
}

</style>

<div id="container"></div>

<script src="d3/d3.min.js" ></script>

<script>
    const boundingBoxWidthFactor = 12;
    const boundingBoxHeight = 20;

    function calcSlopeDegrees(p0, p1, offsetX0, offsetX1) {
        // https://www.mathebibel.de/steigungswinkel
        const opposite = p1.y - p0.y;
        const adjacent = p1.x + offsetX1 - p0.x - offsetX0;
        const m = opposite / adjacent;
        const radians = Math.atan(m);
        const degrees = radians * (180 / Math.PI);
        return degrees;
    }

    function calcRotationOffset(p0, p1) {
        if (p0.x <= p1.x) {
            return 90;
        }
        return -90
    }

    function calcTargetOffsetX(d) {
        let offset = 0;
        if (d.source.x < d.target.x) {
            offset = 0;
        }
        else {
            offset = d.target.name.length * boundingBoxWidthFactor;
        }

        return offset;
    }
    function calcSourceOffsetX(d) {
        let offset = 0;
        if (d.source.x > d.target.x) {
            offset = 0;
        }
        else {
            offset = d.source.name.length * boundingBoxWidthFactor;
        }

        return offset;
    }

    function transformJoint(joint) {
        const sourceOffsetX = calcSourceOffsetX(joint);
        const targetOffsetX = calcTargetOffsetX(joint);
        const slopeDegrees = calcSlopeDegrees(joint.source, joint.target, sourceOffsetX, targetOffsetX);
        const rotationOffset = calcRotationOffset(joint.source, joint.target);

        return `translate(${joint.target.x + targetOffsetX}, ${joint.target.y}) rotate(${rotationOffset + slopeDegrees})`;
    }

    function showGraph(graph) {
        function tick() {
            link
                .attr("x1", d => d.source.x+ calcSourceOffsetX(d))
                .attr("y1", d => d.source.y)
                .attr("x2", d => d.target.x + calcTargetOffsetX(d))
                .attr("y2", d => d.target.y)
            ;
            joint
                .attr("transform", (d) => transformJoint(d))
            ;
            node
                .attr("transform", (d) => `translate(${d.x}, ${d.y - (boundingBoxHeight / 2)})`)
            ;
        }

        function click(event, d) {
            delete d.fx;
            delete d.fy;
            d3.select(this).classed("fixed", false);
            simulation.alpha(1).restart();
        }

        function dragstart() {
            d3.select(this).classed("fixed", true);
        }

        function dragged(event, d) {
            d.fx = clamp(event.x, 0, width);
            d.fy = clamp(event.y, 0, height);
            simulation.alpha(1).restart();
        }

        function clamp(x, lo, hi) {
            return x < lo ? lo : x > hi ? hi : x;
        }

        const height = 2000;
        const width = 2000;

        const svg = d3.create("svg").attr("viewBox", [0, 0, width, height]),
            link = svg
                .selectAll(".link")
                .data(graph.links)
                .join("line")
                .classed("link", true),
            joint = svg
                .selectAll(".joint")
                .data(graph.links)
                .join("polygon")
                .attr("points", "0 0, 10 30, -10 30")
                .attr("r", 1)
                .classed("joint", true)
        ;

        @* const links = .selectAll(".link")
            .append("polygon")
            .attr("points", "250,60 100,400 400,400")
        ; *@

        const node = svg
            .selectAll(".node")
            .data(graph.nodes)
            .join("g")
            .classed("node", true)
            .classed("fixed", d => d.fx !== undefined)
        ;

        node.append("rect")
            .attr("width", d => d.name.length * boundingBoxWidthFactor)
            .attr("height", boundingBoxHeight)
        ;

        node.append("text")
            .attr("dy", ".80em")
            .attr("dx", ".40em")
            .classed("text", true)
            .text(d => d.name)
        ;

        const simulation = d3
            .forceSimulation()
            .nodes(graph.nodes)
            @* .force("charge", d3.forceManyBody().strength(-500)) *@
            .force("center", d3.forceCenter(width / 2, height / 2))
            .force("link", d3.forceLink(graph.links).distance(250))
            .on("tick", tick)
        ;

        const drag = d3
            .drag()
            .on("start", dragstart)
            .on("drag", dragged)
        ;

        node.call(drag).on("click", click);

        const zoom = d3.zoom().on("zoom", e => {
            svg.attr("transform", (transform = e.transform));
        });

        svg
            .call(zoom)
            .call(zoom.transform, d3.zoomIdentity)
        ;

        const container = document.getElementById("container");
        while(container.firstChild){
            container.removeChild(container.firstChild);
        }
        container.append(svg.node());
    }
</script>

@code {

  [Parameter, EditorRequired] public IEnumerable<ModuleModel>? Modules { get; set; }

  protected override async Task OnAfterRenderAsync(bool firstRender) {
    
     if (Modules is null) {
        return;
    }
    var modules = Modules.Where(x => x.Name is not null).ToArray();
    var map = modules.ToDictionary(x => x.Name);
    var links = new List<LinkModel>();
    for (int sourceIndex = 0; sourceIndex < modules.Length; sourceIndex++) 
    {
        var module = modules[sourceIndex];

        foreach (var reference in module.Uses) {
            if (!map.TryGetValue(reference, out var referencedModule)) 
            {
                continue;
            }

            var destinationIndex = Array.IndexOf(modules, referencedModule);

            links.Add(
                new ( 
                    From: new (
                        Index: sourceIndex, 
                        Name: modules[sourceIndex].Name
                    ), 
                    To: new (
                        Index: destinationIndex, 
                        Name: modules[destinationIndex].Name
                    ) 
                )
            );
        }
    }
    var graph = new {
        nodes = modules.Select(x => new { name = x.Name } ).ToArray(),
        links = links.Select(x => new {
            source = x.From.Index,
            sourceName = x.From.Name,
            target = x.To.Index,
            targetName = x.To.Name
        })
    };

    await js.InvokeVoidAsync("showGraph", graph);
  }

}
